<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Network Graph</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0a; overflow: hidden; font-family: 'Malgun Gothic', sans-serif; }
  canvas { display: block; cursor: default; }
  #legend {
    position: fixed;
    top: 20px;
    left: 20px;
    color: #fff;
    font-size: 13px;
    line-height: 1.8;
    z-index: 10;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    opacity: 0.8;
    transition: opacity 0.2s;
  }
  .legend-item:hover { opacity: 1; }
  .legend-item.active { opacity: 1; font-weight: bold; }
  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  #info {
    position: fixed;
    top: 20px;
    right: 20px;
    color: rgba(255,255,255,0.5);
    font-size: 12px;
    text-align: right;
    z-index: 10;
  }
  @media (max-width: 700px) {
    #legend {
      top: auto;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 4px 12px;
      padding: 10px 12px;
      background: rgba(10,10,10,0.85);
      font-size: 11px;
      line-height: 1.4;
    }
    .legend-dot { width: 8px; height: 8px; }
    .legend-item { gap: 4px; }
    #info { font-size: 10px; top: 8px; right: 8px; }
  }
  #tooltip {
    position: fixed;
    padding: 6px 12px;
    background: rgba(0,0,0,0.85);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 6px;
    color: #fff;
    font-size: 13px;
    pointer-events: none;
    display: none;
    z-index: 100;
    white-space: nowrap;
  }
</style>
</head>
<body>
<div id="legend"></div>
<div id="info">총 노드: <span id="totalCount">0</span>개<br><span style="font-size:11px;opacity:0.6">호버: 정보</span></div>
<div id="tooltip"></div>
<canvas id="canvas"></canvas>

<script>
const data = [
  { name: "조용성", count: 613 },
  { name: "김준석", count: 359 },
  { name: "조소희", count: 276 },
  { name: "주선민", count: 220 },
  { name: "신민기", count: 189 },
  { name: "황지상", count: 149 },
  { name: "전민규", count: 67 },
  { name: "안해인", count: 63 },
  { name: "김아영", count: 38 },
  { name: "최지연", count: 23 },
  { name: "홍석주", count: 18 },
  { name: "안명선", count: 17 },
  { name: "이근민", count: 13 },
  { name: "이선빈", count: 11 },
  { name: "김주형", count: 10 },
  { name: "문정인", count: 8 },
  { name: "남효신", count: 4 },
];

const colors = [
  "#FF3366", "#FFaa00", "#00CCFF", "#FF66CC", "#66FF66",
  "#FFFF44", "#FF8833", "#AA66FF", "#00FFAA", "#FF4444",
  "#88CCFF", "#FFCCAA", "#CC88FF", "#44FFCC", "#FF6699",
  "#AADDFF", "#FFFFFF"
];

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");
let W, H, centerX, centerY, radius;


function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  centerX = W / 2;
  centerY = H / 2;
  const isNarrow = W < 700;
  const legendHeight = isNarrow ? 60 : 0;
  centerY = (H - legendHeight) / 2;
  radius = Math.min(W, H - legendHeight) * 0.38;
}
resize();
window.addEventListener("resize", () => { resize(); initNodes(); });

// Build nodes
let nodes = [];
let links = [];

function initNodes() {
  nodes = [];
  links = [];

  const totalNodes = data.reduce((s, d) => s + d.count, 0);
  document.getElementById("totalCount").textContent = totalNodes;

  data.forEach((group, gi) => {
    const color = colors[gi % colors.length];
    const groupNodes = [];

    for (let i = 0; i < group.count; i++) {
      const angle = Math.PI * 2 * Math.random();
      const r = radius * (0.3 + Math.random() * 0.7);
      const node = {
        x: centerX + Math.cos(angle) * r,
        y: centerY + Math.sin(angle) * r,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        color: color,
        group: gi,
        radius: group.count > 100 ? 2.5 : (group.count > 30 ? 3 : 3.5),
        name: group.name,
      };
      nodes.push(node);
      groupNodes.push(node);
    }

    // create links within group (sparse)
    const maxLinks = Math.min(group.count * 2, group.count * (group.count - 1) / 2);
    const linkCount = Math.min(maxLinks, Math.floor(group.count * 1.5));
    for (let i = 0; i < linkCount; i++) {
      const a = groupNodes[Math.floor(Math.random() * groupNodes.length)];
      const b = groupNodes[Math.floor(Math.random() * groupNodes.length)];
      if (a !== b) {
        links.push({ source: a, target: b });
      }
    }

    // cross-group links (sparse)
    if (gi > 0) {
      const prevStart = nodes.length - group.count - data[gi - 1].count;
      const crossCount = Math.min(5, Math.floor(group.count * 0.05) + 1);
      for (let i = 0; i < crossCount; i++) {
        const a = groupNodes[Math.floor(Math.random() * groupNodes.length)];
        const bIdx = prevStart + Math.floor(Math.random() * data[gi - 1].count);
        if (bIdx >= 0 && bIdx < nodes.length) {
          links.push({ source: a, target: nodes[bIdx] });
        }
      }
    }
  });
}

initNodes();

// Force simulation
function simulate() {
  const cellSize = 40;
  const grid = {};
  nodes.forEach(n => {

    const key = Math.floor(n.x / cellSize) + "," + Math.floor(n.y / cellSize);
    if (!grid[key]) grid[key] = [];
    grid[key].push(n);
  });

  nodes.forEach(n => {

    const cx = Math.floor(n.x / cellSize);
    const cy = Math.floor(n.y / cellSize);
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const cell = grid[(cx + dx) + "," + (cy + dy)];
        if (!cell) continue;
        for (const other of cell) {
          if (other === n) continue;
          const ddx = n.x - other.x;
          const ddy = n.y - other.y;
          const dist = Math.sqrt(ddx * ddx + ddy * ddy) || 1;
          if (dist < 30) {
            const force = (30 - dist) * 0.02;
            n.vx += (ddx / dist) * force;
            n.vy += (ddy / dist) * force;
          }
        }
      }
    }
  });

  nodes.forEach(n => {

    const dx = n.x - centerX;
    const dy = n.y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > radius) {
      n.vx -= dx * 0.02;
      n.vy -= dy * 0.02;
    }
    n.vx += (centerX - n.x) * 0.0002;
    n.vy += (centerY - n.y) * 0.0002;
  });

  links.forEach(l => {

    const dx = l.target.x - l.source.x;
    const dy = l.target.y - l.source.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    if (dist > 80) {
      const force = (dist - 80) * 0.0001;
      const fx = dx / dist * force;
      const fy = dy / dist * force;
      l.source.vx += fx;
      l.source.vy += fy;
      l.target.vx -= fx;
      l.target.vy -= fy;
    }
  });

  nodes.forEach(n => {

    n.vx *= 0.85;
    n.vy *= 0.85;
    n.x += n.vx;
    n.y += n.vy;
  });
}

// Interaction state
let hoveredNode = null;
let highlightGroup = -1;

function findNodeAt(sx, sy) {
  const hitRadius = 8;
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    const dx = sx - n.x;
    const dy = sy - n.y;
    if (dx * dx + dy * dy < hitRadius * hitRadius) return n;
  }
  return null;
}

// Mouse events (hover only)
canvas.addEventListener("mousemove", (e) => {
  const node = findNodeAt(e.clientX, e.clientY);
  if (node) {
    hoveredNode = node;
    highlightGroup = node.group;
    canvas.style.cursor = "pointer";
    tooltip.style.display = "block";
    tooltip.style.left = (e.clientX + 14) + "px";
    tooltip.style.top = (e.clientY - 10) + "px";
    const d = data[node.group];
    tooltip.innerHTML = `<span style="color:${node.color}">●</span> ${d.name} <span style="opacity:0.5">(${d.count}개)</span>`;
  } else {
    hoveredNode = null;
    highlightGroup = -1;
    canvas.style.cursor = "default";
    tooltip.style.display = "none";
  }
});

canvas.addEventListener("mouseleave", () => {
  hoveredNode = null;
  highlightGroup = -1;
  tooltip.style.display = "none";
});

function draw() {
  ctx.clearRect(0, 0, W, H);

  const dimming = highlightGroup >= 0;

  // Draw links
  ctx.lineWidth = 0.5;
  links.forEach(l => {
    if (dimming) {
      if (l.source.group === highlightGroup || l.target.group === highlightGroup) {
        ctx.globalAlpha = 0.15;
        ctx.strokeStyle = data[highlightGroup] ? colors[highlightGroup] : "#ffffff";
      } else {
        ctx.globalAlpha = 0.015;
        ctx.strokeStyle = "#ffffff";
      }
    } else {
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = "#ffffff";
    }
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.stroke();
  });

  // Draw nodes
  nodes.forEach(n => {
    if (dimming) {
      ctx.globalAlpha = (n.group === highlightGroup) ? 1 : 0.12;
    } else {
      ctx.globalAlpha = 0.85;
    }
    const r = (hoveredNode === n) ? n.radius * 2.5 : n.radius;
    ctx.beginPath();
    ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
    ctx.fillStyle = n.color;
    ctx.fill();
  });

  // Draw hovered node glow
  if (hoveredNode) {
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.arc(hoveredNode.x, hoveredNode.y, 12, 0, Math.PI * 2);
    ctx.fillStyle = hoveredNode.color;
    ctx.fill();
  }

  ctx.globalAlpha = 1;
}

let frame = 0;
function animate() {
  simulate();
  draw();
  frame++;
  requestAnimationFrame(animate);
}
animate();

// Legend with click interaction
const legendEl = document.getElementById("legend");
let legendHighlight = -1;

data.forEach((d, i) => {
  const item = document.createElement("div");
  item.className = "legend-item";
  item.innerHTML = `<span class="legend-dot" style="background:${colors[i]}"></span>
    <span>${d.name} (${d.count})</span>`;

  item.addEventListener("mouseenter", () => {
    highlightGroup = i;
    item.classList.add("active");
  });
  item.addEventListener("mouseleave", () => {
    if (legendHighlight < 0) highlightGroup = -1;
    item.classList.remove("active");
  });
  item.addEventListener("click", () => {
    if (legendHighlight === i) {
      legendHighlight = -1;
      highlightGroup = -1;
      item.classList.remove("active");
    } else {
      legendHighlight = i;
      highlightGroup = i;
      document.querySelectorAll(".legend-item").forEach(el => el.classList.remove("active"));
      item.classList.add("active");
    }
  });

  legendEl.appendChild(item);
});
</script>
</body>
</html>
