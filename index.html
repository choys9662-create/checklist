<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Network Graph</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    overflow: hidden;
    font-family: 'Malgun Gothic', sans-serif;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  canvas {
    display: block;
    cursor: default;
  }
  #legend {
    position: fixed;
    top: 20px;
    left: 20px;
    color: #fff;
    font-size: 13px;
    line-height: 1.8;
    z-index: 10;
  }
  #legendToggle {
    position: fixed;
    top: 16px;
    left: 16px;
    z-index: 20;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 8px 12px;
    border: 1px solid rgba(255,255,255,0.25);
    border-radius: 8px;
    background: rgba(0,0,0,0.82);
    color: #fff;
    font-size: 12px;
    line-height: 1;
    cursor: pointer;
  }
  #legendToggle:hover {
    background: rgba(255,255,255,0.1);
  }
  #legendToggle:focus-visible {
    outline: 2px solid #fff;
    outline-offset: 2px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    opacity: 0.8;
    transition: opacity 0.2s;
  }
  .legend-item:hover { opacity: 1; }
  .legend-item.active { opacity: 1; font-weight: bold; }
  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  #info {
    position: fixed;
    top: 20px;
    right: 20px;
    color: rgba(255,255,255,0.5);
    font-size: 12px;
    text-align: right;
    z-index: 10;
  }
  #tooltip {
    position: fixed;
    padding: 6px 12px;
    background: rgba(0,0,0,0.85);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 6px;
    color: #fff;
    font-size: 13px;
    pointer-events: none;
    display: none;
    z-index: 100;
    white-space: nowrap;
  }
  @media (max-width: 768px) {
    #legendToggle {
      display: inline-flex;
    }
    #legend.is-mobile {
      top: 12px;
      left: 12px;
      width: min(78vw, 320px);
      height: calc(100dvh - 24px);
      padding: 12px;
      overflow-y: auto;
      background: rgba(0,0,0,0.88);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 10px;
      transform: translateX(calc(-100% - 16px));
      opacity: 0;
      pointer-events: none;
      transition: transform 0.25s ease, opacity 0.2s ease;
    }
    #legend.is-mobile.is-open {
      transform: translateX(0);
      opacity: 1;
      pointer-events: auto;
    }
    #info {
      top: 12px;
      right: 12px;
      padding: 6px 8px;
      background: rgba(0,0,0,0.48);
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.45;
    }
  }
</style>
</head>
<body>
<button id="legendToggle" type="button" aria-controls="legend" aria-expanded="false">&#48276;&#47168;</button>
<div id="legend"></div>
<div id="info">총 노드: <span id="totalCount">0</span>개<br><span style="font-size:11px;opacity:0.6">휠: 줌 | 드래그: 이동 | 호버: 정보</span></div>
<div id="tooltip"></div>
<canvas id="canvas"></canvas>

<script>
const data = [
  { name: "조용성", count: 613 },
  { name: "김준석", count: 359 },
  { name: "조소희", count: 276 },
  { name: "주선민", count: 220 },
  { name: "신민기", count: 189 },
  { name: "황지상", count: 149 },
  { name: "전민규", count: 67 },
  { name: "안해인", count: 63 },
  { name: "김아영", count: 38 },
  { name: "최지연", count: 23 },
  { name: "홍석주", count: 18 },
  { name: "안명선", count: 17 },
  { name: "이근민", count: 13 },
  { name: "이선빈", count: 11 },
  { name: "김주형", count: 10 },
  { name: "문정인", count: 8 },
  { name: "남효신", count: 4 },
];

const colors = [
  "#FF3366", "#FFaa00", "#00CCFF", "#FF66CC", "#66FF66",
  "#FFFF44", "#FF8833", "#AA66FF", "#00FFAA", "#FF4444",
  "#88CCFF", "#FFCCAA", "#CC88FF", "#44FFCC", "#FF6699",
  "#AADDFF", "#FFFFFF"
];

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");
const legendEl = document.getElementById("legend");
const legendToggle = document.getElementById("legendToggle");
const MOBILE_BREAKPOINT = 768;
const CANVAS_MARGIN = 16;
const MIN_CANVAS_SIDE = 240;
const BASE_LAYOUT_SIDE = 920;
let W = 0, H = 0, centerX = 0, centerY = 0, radius = 0;
let nodes = [];
let links = [];
let isMobile = false;
let isLegendOpen = false;
let layoutScale = 1;

// Transform state (zoom & pan)
let transform = { x: 0, y: 0, scale: 1 };
const interaction = {
  enableNodeDrag: false,
  enablePan: false,
  enableZoom: false
};

function updateNodeVisualScale() {
  if (!nodes.length) return;
  nodes.forEach((n) => {
    n.radius = Math.max(1.05, n.baseRadius * layoutScale);
  });
}

function applyResponsiveUI() {
  const mobileNow = window.innerWidth <= MOBILE_BREAKPOINT;
  const modeChanged = mobileNow !== isMobile;
  isMobile = mobileNow;

  if (!isMobile) {
    isLegendOpen = true;
  } else if (modeChanged) {
    isLegendOpen = false;
  }

  legendEl.classList.toggle("is-mobile", isMobile);
  legendEl.classList.toggle("is-open", !isMobile || isLegendOpen);
  legendToggle.setAttribute("aria-expanded", String(!isMobile || isLegendOpen));
  legendToggle.textContent = isMobile && isLegendOpen ? "\uB2EB\uAE30" : "\uBC94\uB840";
}

function resize() {
  const prevCenterX = centerX;
  const prevCenterY = centerY;
  const prevRadius = radius;
  const side = Math.max(
    MIN_CANVAS_SIDE,
    Math.min(window.innerWidth - CANVAS_MARGIN, window.innerHeight - CANVAS_MARGIN)
  );
  if (side === W && side === H) return false;

  W = canvas.width = side;
  H = canvas.height = side;
  canvas.style.width = side + "px";
  canvas.style.height = side + "px";
  layoutScale = Math.max(0.42, Math.min(1, side / BASE_LAYOUT_SIDE));
  centerX = W / 2;
  centerY = H / 2;
  radius = Math.min(W, H) * (0.45 + (1 - layoutScale) * 0.04);

  if (nodes.length && prevRadius > 0) {
    const ratio = radius / prevRadius;
    nodes.forEach((n) => {
      n.x = centerX + (n.x - prevCenterX) * ratio;
      n.y = centerY + (n.y - prevCenterY) * ratio;
    });
  }
  updateNodeVisualScale();
  return true;
}
applyResponsiveUI();
resize();
let resizeQueued = false;
window.addEventListener("resize", () => {
  if (resizeQueued) return;
  resizeQueued = true;
  requestAnimationFrame(() => {
    resizeQueued = false;
    applyResponsiveUI();
    resize();
  });
});

function initNodes() {
  nodes = [];
  links = [];

  const totalNodes = data.reduce((s, d) => s + d.count, 0);
  document.getElementById("totalCount").textContent = totalNodes;

  data.forEach((group, gi) => {
    const color = colors[gi % colors.length];
    const groupNodes = [];

    for (let i = 0; i < group.count; i++) {
      const angle = Math.PI * 2 * Math.random();
      const r = radius * Math.sqrt(Math.random()) * 0.98;
      const baseRadius = group.count > 100 ? 2.5 : (group.count > 30 ? 3 : 3.5);
      const node = {
        x: centerX + Math.cos(angle) * r,
        y: centerY + Math.sin(angle) * r,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        color: color,
        group: gi,
        baseRadius: baseRadius,
        radius: Math.max(1.05, baseRadius * layoutScale),
        name: group.name,
      };
      nodes.push(node);
      groupNodes.push(node);
    }

    // create links within group (sparse)
    const maxLinks = Math.min(group.count * 2, group.count * (group.count - 1) / 2);
    const linkCount = Math.min(maxLinks, Math.floor(group.count * 1.5));
    for (let i = 0; i < linkCount; i++) {
      const a = groupNodes[Math.floor(Math.random() * groupNodes.length)];
      const b = groupNodes[Math.floor(Math.random() * groupNodes.length)];
      if (a !== b) {
        links.push({ source: a, target: b });
      }
    }

    // cross-group links (sparse)
    if (gi > 0) {
      const prevStart = nodes.length - group.count - data[gi - 1].count;
      const crossCount = Math.min(5, Math.floor(group.count * 0.05) + 1);
      for (let i = 0; i < crossCount; i++) {
        const a = groupNodes[Math.floor(Math.random() * groupNodes.length)];
        const bIdx = prevStart + Math.floor(Math.random() * data[gi - 1].count);
        if (bIdx >= 0 && bIdx < nodes.length) {
          links.push({ source: a, target: nodes[bIdx] });
        }
      }
    }
  });
}

initNodes();

// Force simulation
function simulate() {
  const cellSize = Math.max(16, 40 * layoutScale);
  const repelDist = Math.max(12, 30 * layoutScale);
  const linkTargetDist = Math.max(36, 80 * layoutScale);
  const grid = {};
  nodes.forEach(n => {
    if (n.dragging) return;
    const key = Math.floor(n.x / cellSize) + "," + Math.floor(n.y / cellSize);
    if (!grid[key]) grid[key] = [];
    grid[key].push(n);
  });

  nodes.forEach(n => {
    if (n.dragging) return;
    const cx = Math.floor(n.x / cellSize);
    const cy = Math.floor(n.y / cellSize);
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const cell = grid[(cx + dx) + "," + (cy + dy)];
        if (!cell) continue;
        for (const other of cell) {
          if (other === n) continue;
          const ddx = n.x - other.x;
          const ddy = n.y - other.y;
          const dist = Math.sqrt(ddx * ddx + ddy * ddy) || 1;
          if (dist < repelDist) {
            const force = (repelDist - dist) * 0.02;
            n.vx += (ddx / dist) * force;
            n.vy += (ddy / dist) * force;
          }
        }
      }
    }
  });

  nodes.forEach(n => {
    if (n.dragging) return;
    const dx = n.x - centerX;
    const dy = n.y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > radius) {
      n.vx -= dx * 0.02;
      n.vy -= dy * 0.02;
    }
    n.vx += (centerX - n.x) * 0.0002;
    n.vy += (centerY - n.y) * 0.0002;
  });

  links.forEach(l => {
    if (l.source.dragging || l.target.dragging) return;
    const dx = l.target.x - l.source.x;
    const dy = l.target.y - l.source.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    if (dist > linkTargetDist) {
      const force = (dist - linkTargetDist) * 0.0001;
      const fx = dx / dist * force;
      const fy = dy / dist * force;
      l.source.vx += fx;
      l.source.vy += fy;
      l.target.vx -= fx;
      l.target.vy -= fy;
    }
  });

  nodes.forEach(n => {
    if (n.dragging) return;
    n.vx *= 0.85;
    n.vy *= 0.85;
    n.x += n.vx;
    n.y += n.vy;
  });
}

// Interaction state
let hoveredNode = null;
let highlightGroup = -1;
let dragNode = null;
let isPanning = false;
let panStart = { x: 0, y: 0 };
let lastMouse = { x: 0, y: 0 };

// Convert screen coords to world coords
function screenToWorld(sx, sy) {
  return {
    x: (sx - transform.x) / transform.scale,
    y: (sy - transform.y) / transform.scale
  };
}

function findNodeAt(sx, sy) {
  const world = screenToWorld(sx, sy);
  const hitRadius = Math.max(5, 8 * layoutScale) / transform.scale;
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    const dx = world.x - n.x;
    const dy = world.y - n.y;
    if (dx * dx + dy * dy < hitRadius * hitRadius) return n;
  }
  return null;
}

function getCanvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
}

// Mouse events
canvas.addEventListener("mousemove", (e) => {
  const pos = getCanvasCoords(e);
  lastMouse.x = pos.x;
  lastMouse.y = pos.y;

  if (interaction.enableNodeDrag && dragNode) {
    const world = screenToWorld(pos.x, pos.y);
    dragNode.x = world.x;
    dragNode.y = world.y;
    dragNode.vx = 0;
    dragNode.vy = 0;
    canvas.style.cursor = "grabbing";
    return;
  }

  if (interaction.enablePan && isPanning) {
    transform.x += pos.x - panStart.x;
    transform.y += pos.y - panStart.y;
    panStart.x = pos.x;
    panStart.y = pos.y;
    canvas.style.cursor = "grabbing";
    return;
  }

  const node = findNodeAt(pos.x, pos.y);
  if (node) {
    hoveredNode = node;
    highlightGroup = node.group;
    canvas.style.cursor = "pointer";
    tooltip.style.display = "block";
    tooltip.style.left = (e.clientX + 14) + "px";
    tooltip.style.top = (e.clientY - 10) + "px";
    const d = data[node.group];
    tooltip.innerHTML = `<span style="color:${node.color}">●</span> ${d.name} <span style="opacity:0.5">(${d.count}개)</span>`;
  } else {
    hoveredNode = null;
    highlightGroup = -1;
    canvas.style.cursor = "default";
    tooltip.style.display = "none";
  }
});

canvas.addEventListener("mousedown", (e) => {
  if (isMobile && isLegendOpen) {
    isLegendOpen = false;
    applyResponsiveUI();
  }

  if (!interaction.enableNodeDrag && !interaction.enablePan) return;

  const pos = getCanvasCoords(e);
  const node = findNodeAt(pos.x, pos.y);
  if (interaction.enableNodeDrag && node) {
    dragNode = node;
    node.dragging = true;
    canvas.style.cursor = "grabbing";
    // restart simulation while dragging
    if (frame >= 600) frame = 580;
  } else if (interaction.enablePan) {
    isPanning = true;
    panStart.x = pos.x;
    panStart.y = pos.y;
    canvas.style.cursor = "grabbing";
  }
});

canvas.addEventListener("touchstart", () => {
  if (isMobile && isLegendOpen) {
    isLegendOpen = false;
    applyResponsiveUI();
  }
}, { passive: true });

canvas.addEventListener("mouseup", () => {
  if (interaction.enableNodeDrag && dragNode) {
    dragNode.dragging = false;
    dragNode = null;
  }
  if (interaction.enablePan) isPanning = false;
  canvas.style.cursor = "default";
});

canvas.addEventListener("mouseleave", () => {
  hoveredNode = null;
  highlightGroup = -1;
  tooltip.style.display = "none";
  if (interaction.enableNodeDrag && dragNode) {
    dragNode.dragging = false;
    dragNode = null;
  }
  if (interaction.enablePan) isPanning = false;
});

// Zoom with mouse wheel
canvas.addEventListener("wheel", (e) => {
  if (!interaction.enableZoom) return;

  e.preventDefault();
  const pos = getCanvasCoords(e);
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
  const newScale = Math.max(0.3, Math.min(5, transform.scale * zoomFactor));

  // zoom toward mouse position
  const mx = pos.x;
  const my = pos.y;
  transform.x = mx - (mx - transform.x) * (newScale / transform.scale);
  transform.y = my - (my - transform.y) * (newScale / transform.scale);
  transform.scale = newScale;
}, { passive: false });

// Double click to reset view
canvas.addEventListener("dblclick", () => {
  transform = { x: 0, y: 0, scale: 1 };
});

legendToggle.addEventListener("click", () => {
  if (!isMobile) return;
  isLegendOpen = !isLegendOpen;
  applyResponsiveUI();
});

window.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && isMobile && isLegendOpen) {
    isLegendOpen = false;
    applyResponsiveUI();
  }
});

function draw() {
  ctx.clearRect(0, 0, W, H);

  ctx.save();
  ctx.translate(transform.x, transform.y);
  ctx.scale(transform.scale, transform.scale);

  const dimming = highlightGroup >= 0;

  // Draw links
  ctx.lineWidth = 0.5 / transform.scale;
  links.forEach(l => {
    if (dimming) {
      if (l.source.group === highlightGroup || l.target.group === highlightGroup) {
        ctx.globalAlpha = 0.15;
        ctx.strokeStyle = data[highlightGroup] ? colors[highlightGroup] : "#ffffff";
      } else {
        ctx.globalAlpha = 0.015;
        ctx.strokeStyle = "#ffffff";
      }
    } else {
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = "#ffffff";
    }
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.stroke();
  });

  // Draw nodes
  nodes.forEach(n => {
    if (dimming) {
      ctx.globalAlpha = (n.group === highlightGroup) ? 1 : 0.12;
    } else {
      ctx.globalAlpha = 0.85;
    }
    const r = (hoveredNode === n) ? n.radius * 2.5 : n.radius;
    ctx.beginPath();
    ctx.arc(n.x, n.y, r / transform.scale * transform.scale, 0, Math.PI * 2);
    ctx.fillStyle = n.color;
    ctx.fill();
  });

  // Draw hovered node glow
  if (hoveredNode) {
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.arc(hoveredNode.x, hoveredNode.y, Math.max(6, 12 * layoutScale), 0, Math.PI * 2);
    ctx.fillStyle = hoveredNode.color;
    ctx.fill();
  }

  ctx.restore();
  ctx.globalAlpha = 1;
}

let frame = 0;
function animate() {
  simulate();
  draw();
  frame++;
  requestAnimationFrame(animate);
}
animate();

// Legend with click interaction
let legendHighlight = -1;

data.forEach((d, i) => {
  const item = document.createElement("div");
  item.className = "legend-item";
  item.innerHTML = `<span class="legend-dot" style="background:${colors[i]}"></span>
    <span>${d.name} (${d.count})</span>`;

  item.addEventListener("mouseenter", () => {
    highlightGroup = i;
    item.classList.add("active");
  });
  item.addEventListener("mouseleave", () => {
    if (legendHighlight < 0) highlightGroup = -1;
    item.classList.remove("active");
  });
  item.addEventListener("click", () => {
    if (legendHighlight === i) {
      legendHighlight = -1;
      highlightGroup = -1;
      item.classList.remove("active");
    } else {
      legendHighlight = i;
      highlightGroup = i;
      document.querySelectorAll(".legend-item").forEach(el => el.classList.remove("active"));
      item.classList.add("active");
    }
  });

  legendEl.appendChild(item);
});
</script>
</body>
</html>
